#+title: pcbro: Wire-Cell PCB Anode Readout Package

This WCT "user package" provides some Wire-Cell Toolkit components and support code for the PCB anode readout (pcbro) R&D and specifically its use in the 50L test detector.

Main features:

C++ 
- 50L detector data decoding (stand-alone)
- WCT component to ingest 50L data

Python module/CLI
- Generate WCT "wires" file
- Convert GARFIELD responses to WCT format
- Diagnostic/debugging plots

Jsonnet/JSON
- WCT configuration to run PCB anode data, signal processing, simulation and other WCT jobs.
- Generated WCT wires and response files generated

* Install

This package provides a Wire-Cell Toolkit User Package (WCUP) building a WCT plugin library and it provides a python module.  It requires these two parts of a usual Wire-Cell Toolkit installation.

** Install Wire-Cell Toolkit Plugin Library

#+begin_example
  $ ./wcb configure --prefix=/path/to/install \
        --with-wct=$HOME/opt/wct \
        [...maybe other --with-* flags...]
  $ ./wcb --notests install
  $ ./wcb --alltests
#+end_example

Note, the install library location must be added to ~LD_LIBRARY_PATH~ and you may want to add ~pcbro~ cfg area to ~WIRECELL_PATH~.  Assuming these variables have already been configured for WCT itself:

#+begin_example
  $ LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/install/lib
  $ WIRECELL_PATH=$WIRECELL_PATH:/path/to/pcbro/cfg
#+end_example

** Python module and CLI

The ~pcbro~ package provides a ~wirecell.pcbro~ Python module and a CLI called as ~wirecell-pcbro~.  It is used for generating PCB anode "wires" files and for processing Garfield output into WCT response file.  It also provides various diagnostic plots.  It is most easily installed alongside the WCT Python modules.  Note, Python3 is required.

#+begin_example
  $ python3 -m venv venv
  $ source venv/bin/activate

  $ cd /path/to/wire-cell-toolkit/python
  $ python -m pip install -e .  
  
  $ cd /path/to/pcbro/python
  $ python -m pip install -e .

  $ wirecell-pcbro --help
#+end_example

* Roadmap

The development roadmap for this package is roughly:

- [X] generate initial package skeleton with [[https://github.com/brettviren/moo][moo]].
- [X] raw data decoder for the ~.bin~ files produced by the 50L DAQ.
- [X] a WCT "source" component that will provide this data as WCT tensors
- [X] a WCT configuration to convert ~.bin~ to ~.npz~ files
- [X] produce event displays to confirm decoder works
- [X] produce fake WCT "wires file" mostly to serve as channel map (save to ~wire-cell-data~)
- [X] develop WCT configuration to run sigproc on ~.bin~ and save results to zero-padded ~.npz~ (with bogus use of PDSP field response functions)
- [ ] progress though field roadmap (below)

- [ ] understand and fix the apparent wrap-around in SP data ([[https://github.com/brettviren/pcbro/issues/1][issue 1]])
- [X] job configuration to save ADC-level and SP-level data to Magnify files. ([[https://github.com/brettviren/pcbro/issues/2][issue 2]])
- [ ] data reduction.  This needs some serious thought and is mostly in the core of WCT.

** Field Roadmap

The PCB poses a greater need for a true 3D field response model than
do wires.  This roadmap gives a phased approach to get closer to the
ideal.

*** 2D response + 2D WCT

Uses GARFIELD "micro wire" approximation

- [X] calculate 2D fields at various radial positions for a single-hole universe using the "many wire" trick and Garfield.
- [X] parse this to produce responses at two "slices" for each plane
- [X] generate WCT ~.json.bz2~ files with choice of which slices to select or average over
- [ ] save "official" response files to ~cfg/~
- [X] understand/fix apparent unipolar contribution to neighbor strips for paths in the shared hole.


*** 3D fields + 2D WCT sim+sigproc

Uses existing WCT unchanged.

- [ ] calculate 3D fields with realistic hole pattern (Garfield++/neBEM?, Garfield++/COMSOL?, pure COMSOL?)
- [ ] calculate response functions for paths starting on a square grid based on the usual 6 impact positions.  In one dimension/plane these span impacts and the other these span "slices" across the strip.  This tries to exploit the orthogonal symmetry of the PCB anode.  In general, (eg with wire planes) we need one set of paths per plane.
- [ ] for each plane, marginalize the response functions over the slice dimension to produce 2D response functions that may be used in current WCT simulation and sigproc


*** 3D fields + new 3D WCT sim

This has two possible branches of development

- [ ] develop full 3D simulation as a conceptual extension to the convolution technique used in current 2D WCT.  This will be very memory and computationally expensive.  We should consider the need for GPU (not merely as an optimization) but retain ability to run on CPU.  This may be something for CCE-PPS to work on.  I expect the best first step is a prototype using PyTorch.

- [ ] develop full 3D simulation as an MC using Garfield++.  Some concerns: too slow? not GPU'able? requires us to get deeper Garfield++ experience.


* Using PCBro

This goes through some basic programs to exercise parts of PCBro.

** Basic raw data decoding

The basic unpacking is done by code in [[file:inc/WireCellPcbro/BinFile.h][BinFile.h]].  It can be tested like:

#+begin_example
  $ ./build/test_BinFile <test> <file.bin>
#+end_example

With ~<test>~ being one of: read, package, link, trigger and file.

The WCT component that can inject ~.bin~ files into a WCT graph is
~PcbroRawSource~ and can be tested directly like:

#+begin_example
  $ ./build/test_RawSource <file.bin>
#+end_example

** Use Wire-Cell Toolkit

Install WCT with PDSP's data files (at least) doing something like:

#+begin_example
  $ cd /path/to/wire-cell-toolkit
  $ ./wcb configure --prefix=$PREFIX --with-jsonnet=$HOME/opt/jsonnet
  $ ./wcb --notests install --install-config=all
#+end_example

Make sure ~WIRECELL_PATH~ includes WCT's installed config and data
directory and pcbro's ~cfg/~, eg:

#+begin_example
  $ export WIRECELL_PATH=$PREFIX/share/wirecell:$HOME/dev/pcbro/cfg
#+end_example

** Wires 

PCB anode of course has strips but for sigproc we don't care about actual geometry and just need to gives conductor ordering.  PCBro has a WCT-like Python package which generates a "wire" file.


#+begin_example
  $ wirecell-pcbro gen-wires pcbro-wires.txt
  $ wirecell-util convert-oneside-wires pcbro-wires.txt pcbro-wires.json.bz2
#+end_example

The resulting ~.json.bz2~ file should go in a directory listed in your
~WIRECELL_PATH~.  A copy is committed in this repo at [[file:cfg/pcbro-wires.json.bz2][cfg/pcbro-wires.json.bz2]].

** WCT decoding

A PCB anode ~.bin~ file can be read by WCT, decoded and written to a Numpy ~.npz~ array file.  You can then plot the result with ~matplotlib~.  For example:

#+begin_example
  $ wire-cell -l stdout -L debug -l junk.log:debug \
              -A infile=<file.bin> -A outfile=<file.npz> \
              -c cfg/cli-bin-npz.jsonnet 

  $ ipython --pylab
  In [1]: f = numpy.load("<file.npz>")
  In [2]: plt.imshow(f['frame_bin2npz_31'])
  In [3]: plt.savefig("raw-31.png")
#+end_example

or from the CLI

#+begin_example
  $ wirecell-pcbro plot-one -t 31 -a 0.2 -T bin2npz -o raw-31.png raw.npz
#+end_example

[[file:raw-31.png]]

*N.B.: by default the induction plane data is duplicated in order to match WCT's expectation of 3 planes and to allow simultaneous testing of different induction response functions.*

** Fields

PCB anode fields are calculated by GARFIELD by Yichen and the 2D
geometry used is shown in this figure also from Yichen:

#+ATTR_ORG: :width 800
[[file:docs/geometry-2D.png]]

The two planes are conceptually semi-infinite but only the indicated
ranges are considered.  In order to use GARFIELD's analytic 2D
calculation these planes are composed of 400 coplanar 1D "micro-wires"
of diameter 150um.  GARFIELD has a limit on the number of "sensitive"
conductors and so four calculations are required to span the choice of
*R* (right, positive) and *L* and the choice of *a* (nearest hole) and *b*
regions.  These four are needed for each choice of drift path which is
characterized by its (positive, on *R* side) radius.  The results are in
the form of files with these values encoded in their names:

#+begin_example
<radius>_[ind|col]_[L|R]_[a|b].dat
#+end_example

PCBro provides scripts to map these data to the real geometry.  This
mapping is illustrated in the following diagram.  *CAVEAT* the impact
positions *must* be taken on the negative side of the strip centerline
rather than as drawn as WCT sim (impact transform) bakes in this
convention.  The ~wirecell-pcbro convert-garfield~ command uses the
correct convention.

#+ATTR_ORG: :width 600
[[file:docs/collection-impacts-detail.svg]]

For each strip, numbered -5, ..., 0, ..., 5, one of its six
strip-impact positions (SIP) is considered.  Along the strip two
"slices" are considered which are defined as lines bisecting a full
hole on the strip.  For each of these objects the real geometry is
examined to identify which hole is nearest to the SIP along the slice
(ie, the hole into which the electron path should fall) and the radial
location of the path starting point.

The matching GARFIELD data set is then located and mapped to the real
geometry so that the subset of micro-wires that overlap with
(non-hole) electrode region of strip0 may be selected.  Their
responses are summed to provide the response on strip0 to a path at
that strip's SIP and for that slice.

The final response set can be calculated as an average over the two
slices.  Final responses keeping the slices separate may also be produced.

*** Preparing

A number of GARFIELD runs were performed as the process was debugged
and only a certain subset of files should be considered.  The "good"
files from them may be collected with this ~tar~ command:

#+begin_example
  $ tar -cvf garfield-pcb.tar \
   pcb_try/{0.0,0.5,1.0,1.5,2.0,2.5}_ind_R_{a,b}.dat \
   pcb_try/{0.5,1.0,1.5}_col_R_{a,b}.dat \
   pcb_try_add/{0.0,0.2,0.3,0.7,0.8,1.2,1.3,1.7}_col_R_{a,b}.dat \
   pcb_try_Lcorr/{0.0,0.2,0.3,0.5,0.7,0.8,1.0,1.2,1.3,1.5,1.7,2.0,2.5}_{col,ind}_L_{a,b}.dat
  $ tar -tvf garfield-pcb.tar |wc -l
  86
#+end_example

Summary of the directories:

- ~pcb_try~ :: initial set containing radii needed for induction strips.
  Good for ~ind_R~ and some ~col_R~.
- ~pcb_try_add~ :: extended set containing radii needed for collection
  strips but with a geometry bug found which effects only *L* data sets.
  Good for ~col_R~.
- ~pcb_try_Lcorr~ :: rerun of above fixing a bug in geometry that only
  affects *L* collection.  Good for ~col_L~ and ~ind_L~

A WCT ~.json.bz2~ response file may be produced with:

#+begin_example
$ wirecell-pcbro convert-garfield garfield-pcb.tar 
#+end_example

This should run with no errors about "No response for plane ...".
It produces a number of JSON files

- ~pcbro-response-avg.json.bz2~
- ~pcbro-response-slc0.json.bz2~
- ~pcbro-response-slc1.json.bz2~

The trailing file name indicates which slices are left distinct or
averaged.

- avg :: U and V are identical and both average over two inductions slices.
- slc0 :: U is average over both slices V is induction slice 0, W is collection slice 0.
- slc1 :: U is average over both slices V is induction slice 1, W is collection slice 1.

#+begin_center
  $ ./scripts/gen-response.sh
  $ ls pcbro-response-*
  $ feh --keep-zoom-vp --force-aliasing pcbro-response-slc[01]-zoom.png
#+end_center

See next section for downloading the results of this script.
The PNGs produced are committed:

- [[docs/pcbro-response-avg.png]]
- [[docs/pcbro-response-slc0.png]]
- [[docs/pcbro-response-slc1.png]]



** WCT sigproc

The raw ~.bin~ data can be read in, decoded, run through WCT signal processing and the result written to an Numpy ~.npz~ array file

*Caveat:* while the fields are being validated these results do not represent the ultimate efficacy.  See [[Roadmap]] for relevant details.  Until these are finalized, there will not be any officially, versioned field files but the latest can be retrieved:

#+begin_example
  $ wget https://www.phy.bnl.gov/~bviren/tmp/pcbro/pcbro-response-latest.tar
  $ tar -C pcbro/cfg -xf pcbro-response-latest.tar
#+end_example

It includes several different response files and their corresponding display as PNG files.  A particular response file may be given as an option to the ~wire-cell~ CLI:

#+begin_example
  $ wire-cell -l stdout -L debug -l junk.log:debug \
              -A infile=<file.bin> -A outfile=<file.npz> \
              -A resp=pcbro-response-avg.json.bz2 \
              -c cfg/cli-bin-sp-npz.jsonnet

  $ ipython --pylab
  In [1]: f = numpy.load("<file.npz>")
  In [2]: plt.imshow(f['frame_gauss0_31'])  
  In [3]: plt.savefig("trig31-gauss.png")
#+end_example

or from the CLI:

#+begin_example
  $ wirecell-pcbro plot-one -t 31 -a 0.2 -T gauss0 -o sig-31.png sig.npz
#+end_example


[[file:sig-31.png]]


*N.B. again, this does not represent ultimate capabilities as the fields are still being understood.*  The two copies of the induction plane are deconvolved with a different field slice.

** Multiple input files

The ~PcbroRawSource~ may be configured with one or a sequence of input ~.bin~ files and likewise so does the top-level "cli" Jsonnet.  With a little help from the shell you can pass multiple files via:

#+begin_example
  $ rm -f sig.npz
  $ time wire-cell \
    --tla-str outfile="sig.npz" \
    --tla-code infile="[ $(printf '"%s",' /home/bv/work/pcbro/Rawdata_05_26_2020/run01tri/WIB00step18_FEMB_B8_1590484*.bin ) ]" \
    -c cfg/cli-bin-sp-npz.jsonnet

  ...
  [15:14:29.460] D [ pcbro  ] RawSource: end of 29 files
  [15:14:29.460] I [ timer  ] Timer: WireCell::SigProc::OmnibusSigProc : 45.555553 sec
  [15:14:29.460] I [ timer  ] Timer: WireCell::Sio::NumpyFrameSaver : 4.5346904 sec
  [15:14:29.460] I [ timer  ] Timer: pcbro::RawSource : 2.6408951 sec
  [15:14:29.460] I [ timer  ] Timer: WireCell::Aux::TaggedTensorSetFrame : 0.27116203 sec
  [15:14:29.460] I [ timer  ] Timer: WireCell::Gen::DumpFrames : 0.061627306 sec
  [15:14:29.460] I [ timer  ] Timer: Total node execution : 53.06392828375101 sec

  real	0m55.183s
  user	0m52.199s
  sys	0m1.873s

  $ ls /home/bv/work/pcbro/Rawdata_05_26_2020/run01tri/WIB00step18_FEMB_B8_1590484*.bin|wc -l
  29

#+end_example

** Quick and dirty hand scanner

Process many ~.bin~ into a ~.npz~ file and then make a reduced ~.npz~ file by applying a threshold on activity.  The activity is calculated by subtracting a per-channel median and then summing all values above a minimum (def=5) and if the sum is larger than the threshold (default=5000) then save the array to the output ~.npz~.  You can then make a multi-page PDF.

#+begin_example
  $ rm -f raw-muons.npz; wirecell-pcbro activity raw.npz raw-muons.npz
  $ rm -f raw-muons.pdf; wirecell-pcbro plot-many -a 0.2 -o raw-muons.pdf raw-muons.npz
#+end_example


** Magnify support

A standard WCT validation and debugging tool it Magnify.  One can produce a Magnify file from a select trigger which will hold the original raw and signal processed output.

#+begin_example
  $ wire-cell -A resp=pcbro-response-avg.json.bz2 \
              -A start=32 -A triggers=1 \
              -A infile=<file.bin> -A outfile=<file.root> \
              -c cfg/cli-bin-sp-mag.jsonnet
#+end_example


** WCT Simulation

In development.  Something like:

#+begin_example
  $ wire-cell -A outfile=out.npz -c cfg/cli-sim-npz.jsonnet
  $ wire-cell -A resp=pcbro-response-slc0.json.bz2 -A outfile=out-slc0.npz -c cfg/cli-sim-npz.jsonnet
  $ wire-cell -A resp=pcbro-response-slc1.json.bz2 -A outfile=out-slc1.npz -c cfg/cli-sim-npz.jsonnet
  $ wirecell-pcbro plot-one --baseline-subtract=median -t 0  -a 0.2 -T orig0 -o sim.png out.npz
  $ wirecell-pcbro plot-one --baseline-subtract=median -t 0  -a 0.2 -T orig0 -o sim-slc0.png out-slc0.npz
  $ wirecell-pcbro plot-one --baseline-subtract=median -t 0  -a 0.2 -T orig0 -o sim-slc1.png out-slc1.npz
#+end_example
Add ~-l stdout -L debug~ to make ~wire-cell~ a bit more talkative.

[[file:sim.png]]

[[file:sim-slc0.png]]

[[file:sim-slc1.png]]

